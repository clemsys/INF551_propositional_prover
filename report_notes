part 1: proofs are easy

2.1 -> add parentheses in the test

2.2 : on calcule le type de arg et on s'assure qu'il est bien de la forme ... => a où a est le type qu'on veut obtenir
puis en notant x => y le type de l'arg, il reste à prouver x
deux preuves possibles
Please enter the formula to prove:
(A => B) => A => B
Let's prove it.
 |- ((A => B) => (A => B))
? intro x
x : (A => B) |- (A => B)
? intro y
y : A , x : (A => B) |- B
? elim x
y : A , x : (A => B) |- A
? exact y
done.
Proof term is
(fun (x : (A => B)) -> (fun (y : A) -> (x y)))
ou
Please enter the formula to prove:
(A => B) => A => B
Let's prove it.
 |- ((A => B) => (A => B))
? intro x
x : (A => B) |- (A => B)
? exact x
done.
Proof term is
(fun (x : (A => B)) -> x)

2.5
cat proofs/k.proof | dune exec TD4  # commande pour vérifier une preuve

2.6
il faut parse l'argument
garder une liste courante des lemmes à prouver et les amener à la fin
on veut prouver G |- A
on introduit le lemme B : G |- B => A : la preuve globale est donc une fonction
notre preuve est donc App (global_proof, lemma_proof) : on prend comme argument lemma_proof dans la fonction ci-dessus, c'est une substitution

5.4
pas sûr pour certains cas (when y=v) dans has_fv et subst, 8.1.2 du cours, on ne renomme que quand c'est nécessaire

5.6
red peut faire plus d'une réduction mais c'est pour des questions d'efficacité

5.9
p. 19 slides
